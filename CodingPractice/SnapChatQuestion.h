#pragma once
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <iostream>
using namespace std;

/**
* Given an input string, encodes a
* compressed representation using the following method:
*
* 1. Counts the frequency of each character in the string.
* 2. Assigns an output encoding to each input character.
*    All output encodings are made up of '0' and '1' characters.
*    The most common input character should be encoded as "1".
*    The second most common should be encoded as "01".
*    The third most common should be encoded as "001".
*    The n-th most common should be n '0's followed by a single '1'.
*    (If multiple characters occur equally frequently, you may choose an arbitrary order).
* 3. For each character in the input string,
*    the output string should consist of each encoding concatenated together.
*
* ------
*
* As an example, for the input string "bJbb++b":
*  1.  'b' occurs 4 times.
*      '+' occurs 2 times.
*      'J' occurs 1 times.
*  2. Thus, the following encodings are assigned:
*      'b' -> "1"
*      '+' -> "01"
*      'J' -> "001"
*  3. By concatenating the encodings together, we get:
*       "1 001 1 1 01 01 1"
*       Spaces are added for readability, but the actual output
*       should just be "10011101011".
*/

typedef struct EncodedBundle
{
	string encodedString;
	unordered_map<int, char> decodingArray;

	EncodedBundle(string str, unordered_map<int, char> decoing)
	{
		this->encodedString = str;
		this->decodingArray = decoing;
	}

} EncodedBundle;

class SnapChatQuestion
{
public:
	void Test();
private:
	EncodedBundle * Encode(string & input);
	string Decode(EncodedBundle * bundle);

};

bool sortItem(const pair<char, int> & item1, const pair<char, int>& item2);

bool sortItem(const pair<char, int> & item1, const pair<char, int>& item2)
{
	return item2.second < item1.second;
}

void SnapChatQuestion::Test()
{
	// a = 2, b = 2, c = 1, d = 5
	// d:0, b:1, a:2, c:3

	cout << "****SnapChatQuestion****" << endl;

	string input = "adabdbcddd";

	EncodedBundle * bundle = Encode(input);
	cout << " in " << input << " encoded " << bundle->encodedString;
	string decoded = Decode(bundle);
	cout << " decoded " << decoded << endl;
}

EncodedBundle * SnapChatQuestion::Encode(string & input) {
	// TODO: encode input using the method described above
	// and return it as the 'encodedData' parameter below.

	// The 'additionalData' parameter should be used to pass the
	// encoding schema to the decode function.
	unordered_map<char, int> encodingMap;
	unordered_map<int, char> decodingMap;
	vector<pair<char, int>> charSortedPriorityArray;

	string encodedString;

	//n
	for (int i = 0; i < input.size(); i++)
	{
		if (encodingMap.count( input[i] ) == 0 )
		{
			encodingMap[ input[i] ] = 0;
		}
		else
		{
			encodingMap[ input[i] ]++;
		}
	}

	// sort to item to priority 
	//k
	for (auto itr = encodingMap.begin(); itr != encodingMap.end(); itr++)
	{
		charSortedPriorityArray.push_back( make_pair( (char)(*itr).first, (*itr).second ) );
	}

	//klogk
	sort( charSortedPriorityArray.begin(), charSortedPriorityArray.end(), sortItem );


	//assign prioties
	//k
	int priority = 0;
	for (auto itr = charSortedPriorityArray.begin(); itr != charSortedPriorityArray.end(); itr++)
	{
		encodingMap[itr->first] = priority++;
	}

	//n
	//Get encoded count and encode string
	for (int i = 0; i < input.size(); i++)
	{
		int encodingCount = encodingMap[input[i]];

		//k
		while (encodingCount--)
		{
			encodedString.push_back('0');
		}

		encodedString.push_back('1');
	}

	//k
	//set the decoding vector
	for (int i = 0; i < charSortedPriorityArray.size(); i++)
	{
		decodingMap[i] = charSortedPriorityArray[i].first;
	}

	return new EncodedBundle( encodedString, decodingMap );
}

/**
* Given an {@link EncodedBundle} generated by {@link encode()},
* returns the String used to produce it.
*/
string SnapChatQuestion::Decode(EncodedBundle * bundle) {
	// TODO: Use the data in EncodedBundle to reconstruct the original string.

	string decodedString;
	int i = 0;
	int j = 0;

	while (j < bundle->encodedString.size())
	{
		while (bundle->encodedString[j] == '0' )
		{
			j++;
		}

		decodedString.push_back(bundle->decodingArray[j - i]);

		j++;
		i = j;
	}

	delete bundle;
	return decodedString;
}